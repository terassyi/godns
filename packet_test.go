package godns

import (
	"testing"
)

var	DNS_PACKET_DATA [52]byte = [52]byte{
		0x78, 0x02, 0b10101000, 0b10010010, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x00, 0x29, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0c, 0x00, 0x0a, 0x00, 0x08, 0x07, 0xfa, 0xad, 0x8c, 0xd8, 0x2d, 0x23, 0x6c,
		}

var DNS_PACKET_REP_DATA []byte = []byte{
		0x78, 0x02, 0x81, 0x20, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x5d, 0xb8, 0xd8, 0x22,
}

var DNS_PACKET_MANY_ANSWER []byte = []byte{
		0x5a, 0x71, 0x81, 0x00, 0x00, 0x01,
		0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x02, 0x64, 0x63, 0x08, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
		0x65, 0x73, 0x0c, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x73, 0x74, 0x75, 0x64, 0x69, 0x6f, 0x03,
		0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01, 0x02, 0x64, 0x63, 0x08, 0x73, 0x65, 0x72, 0x76,
		0x69, 0x63, 0x65, 0x73, 0x0c, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x73, 0x74, 0x75, 0x64, 0x69,
		0x6f, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26,
		0x02, 0x64, 0x63, 0x13, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x69,
		0x6e, 0x73, 0x69, 0x67, 0x68, 0x74, 0x73, 0x09, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66,
		0x74, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x02, 0x64, 0x63, 0x13, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63,
		0x61, 0x74, 0x69, 0x6f, 0x6e, 0x69, 0x6e, 0x73, 0x69, 0x67, 0x68, 0x74, 0x73, 0x09, 0x6d, 0x69,
		0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x05, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x02, 0x64, 0x63, 0x13, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63,
		0x61, 0x74, 0x69, 0x6f, 0x6e, 0x69, 0x6e, 0x73, 0x69, 0x67, 0x68, 0x74, 0x73, 0x05, 0x61, 0x7a,
		0x75, 0x72, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x02, 0x64, 0x63, 0x13, 0x61, 0x70, 0x70, 0x6c,
		0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x69, 0x6e, 0x73, 0x69, 0x67, 0x68, 0x74, 0x73, 0x05,
		0x61, 0x7a, 0x75, 0x72, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x20, 0x06, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x02, 0x69, 0x6e, 0x02, 0x61,
		0x69, 0x07, 0x6d, 0x6f, 0x6e, 0x69, 0x74, 0x6f, 0x72, 0x05, 0x61, 0x7a, 0x75, 0x72, 0x65, 0x03,
		0x63, 0x6f, 0x6d, 0x00, 0x06, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x02, 0x69, 0x6e, 0x02, 0x61,
		0x69, 0x07, 0x6d, 0x6f, 0x6e, 0x69, 0x74, 0x6f, 0x72, 0x05, 0x61, 0x7a, 0x75, 0x72, 0x65, 0x03,
		0x63, 0x6f, 0x6d, 0x00, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x06, 0x67,
		0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x02, 0x69, 0x6e, 0x02, 0x61, 0x69, 0x0b, 0x70, 0x72, 0x69, 0x76,
		0x61, 0x74, 0x65, 0x6c, 0x69, 0x6e, 0x6b, 0x07, 0x6d, 0x6f, 0x6e, 0x69, 0x74, 0x6f, 0x72, 0x05,
		0x61, 0x7a, 0x75, 0x72, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x06, 0x67, 0x6c, 0x6f, 0x62, 0x61,
		0x6c, 0x02, 0x69, 0x6e, 0x02, 0x61, 0x69, 0x0b, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x6c,
		0x69, 0x6e, 0x6b, 0x07, 0x6d, 0x6f, 0x6e, 0x69, 0x74, 0x6f, 0x72, 0x05, 0x61, 0x7a, 0x75, 0x72,
		0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17,
		0x02, 0x64, 0x63, 0x0e, 0x74, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x6d, 0x61, 0x6e, 0x61, 0x67,
		0x65, 0x72, 0x03, 0x6e, 0x65, 0x74, 0x00, 0x02, 0x64, 0x63, 0x0e, 0x74, 0x72, 0x61, 0x66, 0x66,
		0x69, 0x63, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x03, 0x6e, 0x65, 0x74, 0x00, 0x00, 0x05,
		0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x13, 0x77, 0x75, 0x73, 0x32, 0x30, 0x33, 0x2d,
		0x62, 0x72, 0x65, 0x65, 0x7a, 0x69, 0x65, 0x73, 0x74, 0x2d, 0x69, 0x6e, 0x08, 0x63, 0x6c, 0x6f,
		0x75, 0x64, 0x61, 0x70, 0x70, 0x03, 0x6e, 0x65, 0x74, 0x00, 0x13, 0x77, 0x75, 0x73, 0x32, 0x30,
		0x33, 0x2d, 0x62, 0x72, 0x65, 0x65, 0x7a, 0x69, 0x65, 0x73, 0x74, 0x2d, 0x69, 0x6e, 0x08, 0x63,
		0x6c, 0x6f, 0x75, 0x64, 0x61, 0x70, 0x70, 0x03, 0x6e, 0x65, 0x74, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x28, 0x4e, 0xfd, 0xca,
}
func TestPacket_New(t *testing.T) {
	packet, err := NewPacket(DNS_PACKET_DATA[:])
	if err != nil {
		t.Fatal(err)
	}
	if packet.Header.Id != 0x7802 {
		t.Fatalf("invalid id: wanted 0x7802, actual %x", packet.Header.Id)
	}
	if packet.Header.Arcount != 1 {
		t.Fatalf("invalid arcount: wanted 1, actual %d", packet.Header.Arcount)
	}
	if len(packet.Questions) != 1 {
		t.Fatalf("invalid question section count: wanted 1, actual %d", len(packet.Questions))
	}
	if packet.Questions[0].Class != IN {
		t.Fatalf("invalid question class: wanted IN, actual %s", packet.Questions[0].Class.String())
	}
	if len(packet.Answers) != 0 {
		t.Fatalf("invalid answer section count: wanted 0, actual %d", len(packet.Answers))
	}
	if len(packet.Authoritys) != 0 {
		t.Fatalf("invalid authority section count: wanted 0, actual %d", len(packet.Authoritys))
	}
	if len(packet.Additionals) != 1 {
		t.Fatalf("invalid additional section count: wanted 1, actual %d", len(packet.Additionals))
	}
}

func TestPacket_New_Rep(t *testing.T) {
	packet, err := NewPacket(DNS_PACKET_REP_DATA)
	if err != nil {
		t.Fatal(err)
	}
	if packet.Header.Id != 0x7802 {
		t.Fatalf("invalid id: wanted 0x7802, actual %x", packet.Header.Id)
	}
	if len(packet.Questions) != 1 {
		t.Fatalf("invalid question section count: wanted 1, actual %d", len(packet.Questions))
	}
	if packet.Questions[0].Class != IN {
		t.Fatalf("invalid question class: wanted IN, actual %s", packet.Questions[0].Class.String())
	}
	if len(packet.Answers) != 1 {
		t.Fatalf("invalid answer section count: wanted 1, actual %d", len(packet.Answers))
	}
	if packet.Answers[0].Type != A {
		t.Fatalf("invalid answer type: wanted A, actual %s", packet.Answers[0].Type.String())
	}
}

func TestPacket_New_Big(t *testing.T) {
	packet, err := NewPacket(DNS_PACKET_MANY_ANSWER)
	if err != nil {
		t.Fatal(err)
	}
	if packet.Header.Id != 0x5a71{
		t.Fatalf("invalid id: wanted 0x7802, actual %x", packet.Header.Id)
	}
	if len(packet.Questions) != 1 {
		t.Fatalf("invalid question section count: wanted 1, actual %d", len(packet.Questions))
	}
	if packet.Questions[0].Class != IN {
		t.Fatalf("invalid question class: wanted IN, actual %s", packet.Questions[0].Class.String())
	}
	if len(packet.Answers) != 7 {
		t.Fatalf("invalid answer section count: wanted 1, actual %d", len(packet.Answers))
	}
}

func TestPacket_Serialize(t *testing.T) {
	packet, err := NewPacket(DNS_PACKET_DATA[:])
	if err != nil {
		t.Fatal(err)
	}
	buf, err := packet.Serialize()
	if err != nil {
		t.Fatal(err)
	}
	if len(buf) != len(DNS_PACKET_DATA) {
		t.Fatalf("failed serialize: wanted %d, actual %d", len(DNS_PACKET_DATA), len(buf))
	}
	if buf[10] != DNS_PACKET_DATA[10] {
		t.Fatalf("invalid data: wanted %v, actual %v", buf[10], DNS_PACKET_DATA[10])
	}
	if buf[len(buf)-10] != DNS_PACKET_DATA[len(DNS_PACKET_DATA)-10] {
		t.Fatalf("invalid data: wanted %v, actual %v", buf[len(buf)-10], DNS_PACKET_DATA[len(DNS_PACKET_DATA)-10])
	}
	if buf[30] != DNS_PACKET_DATA[30] {
		t.Fatalf("invalid data: wanted %v, actual %v", buf[30], DNS_PACKET_DATA[30])
	}
}

func TestPacket_Serialize_Rep(t *testing.T) {
	packet, err := NewPacket(DNS_PACKET_REP_DATA)
	if err != nil {
		t.Fatal(err)
	}
	buf, err := packet.Serialize()
	if err != nil {
		t.Fatal(err)
	}
	if len(buf) != len(DNS_PACKET_REP_DATA) {
		t.Fatalf("failed serialize: wanted %d, actual %d", len(DNS_PACKET_REP_DATA), len(buf))
	}
	if buf[10] != DNS_PACKET_REP_DATA[10] {
		t.Fatalf("invalid data: wanted %v, actual %v", buf[10], DNS_PACKET_REP_DATA[10])
	}
	if buf[len(buf)-10] != DNS_PACKET_REP_DATA[len(DNS_PACKET_REP_DATA)-10] {
		t.Fatalf("invalid data: wanted %v, actual %v", buf[len(buf)-10], DNS_PACKET_REP_DATA[len(DNS_PACKET_REP_DATA)-10])
	}
	if buf[30] != DNS_PACKET_REP_DATA[30] {
		t.Fatalf("invalid data: wanted %v, actual %v", buf[30], DNS_PACKET_REP_DATA[30])
	}
}

func TestPacket_Serialize_Big(t *testing.T) {
	packet, err := NewPacket(DNS_PACKET_MANY_ANSWER[:])
	if err != nil {
		t.Fatal(err)
	}
	buf, err := packet.Serialize()
	if err != nil {
		t.Fatal(err)
	}
	if len(buf) != len(DNS_PACKET_MANY_ANSWER) {
		t.Fatalf("failed serialize: wanted %d, actual %d", len(DNS_PACKET_MANY_ANSWER), len(buf))
	}
	if buf[10] != DNS_PACKET_MANY_ANSWER[10] {
		t.Fatalf("invalid data: wanted %v, actual %v", buf[10], DNS_PACKET_MANY_ANSWER[10])
	}
	if buf[len(buf)-10] != DNS_PACKET_MANY_ANSWER[len(DNS_PACKET_MANY_ANSWER)-10] {
		t.Fatalf("invalid data: wanted %v, actual %v", buf[len(buf)-10], DNS_PACKET_MANY_ANSWER[len(DNS_PACKET_MANY_ANSWER)-10])
	}
	if buf[30] != DNS_PACKET_MANY_ANSWER[30] {
		t.Fatalf("invalid data: wanted %v, actual %v", buf[30], DNS_PACKET_MANY_ANSWER[30])
	}
}

func TestHeader_New(t *testing.T) {
	header, err := NewHeader(DNS_PACKET_DATA[:])
	if err != nil {
		t.Fatal(err)
	}
	if header.Id != 0x7802 {
		t.Fatalf("invalid id: wanted 0x7802, actual %x", header.Id)
	}
	if !header.Qr {
		t.Fatalf("invalid qr field: wanted false, actual %v", header.Qr)
	}
	if header.Opcode != UPDATE {
		t.Fatalf("invalid opcode: wanted Update, actual: %s", header.Opcode.String())
	}
	if header.AA {
		t.Fatal("invalid aa flag: wanted false, actual true")
	}
	if header.TC {
		t.Fatal("invalid tc flag: wanted false, actual true")
	}
	if header.RD {
		t.Fatal("invalid rd flag: wanted false, actual true")
	}
	if !header.RA {
		t.Fatal("invalid ra flag: wanted false, actual true")
	}
	if header.AD {
		t.Fatal("invalid ad flag: wanted false, actual true")
	}
	if !header.CD {
		t.Fatal("invalid cd flag: wanted false, actual true")
	}
	if header.RCode != ServFail {
		t.Fatal(header.RCode.Error())
	}
	if header.Qdcount != 1 {
		t.Fatalf("invalid QDCount: wanted 1, actual %d", header.Qdcount)
	}
	if header.Ancount != 0 {
		t.Fatalf("invalid AnCount: wanted 0, actual %d", header.Ancount)
	}
	if header.Nscount != 0 {
		t.Fatalf("invalid NsCount: wanted 0, actual %d", header.Nscount)
	}
	if header.Arcount != 1 {
		t.Fatalf("invalid ArCount: wanted 1, actual %d", header.Arcount)
	}
}

func TestHeader_Serialize(t *testing.T) {
	header, err := NewHeader(DNS_PACKET_DATA[:])
	if err != nil {
		t.Fatal(err)
	}
	data, err := header.Serialize()
	if err != nil {
		t.Fatal(err)
	}
	if data[0] != DNS_PACKET_DATA[0] {
		t.Fatalf("wanted %x, actual %x", DNS_PACKET_DATA[0], data[0])
	}
	if data[2] != DNS_PACKET_DATA[2] {
		t.Fatalf("wanted %x, actual %x", DNS_PACKET_DATA[2], data[2])
	}
	if data[3] != DNS_PACKET_DATA[3] {
		t.Fatalf("wanted %x, actual %x", DNS_PACKET_DATA[3], data[3])
	}
	if data[5] != DNS_PACKET_DATA[5] {
		t.Fatalf("wanted %x, actual %x", DNS_PACKET_DATA[5], data[5])
	}
	if data[7] != DNS_PACKET_DATA[7] {
		t.Fatalf("wanted %x, actual %x", DNS_PACKET_DATA[7], data[7])
	}
	if data[9] != DNS_PACKET_DATA[9] {
		t.Fatalf("wanted %x, actual %x", DNS_PACKET_DATA[9], data[9])
	}
	if data[11] != DNS_PACKET_DATA[11] {
		t.Fatalf("wanted %x, actual %x", DNS_PACKET_DATA[11], data[11])
	}
}
